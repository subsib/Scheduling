%ceci est un canevas possible pour un mémoire en français; 
%pour l'anglais (américain ou UK) c'est facile à adapter
%il y a de nombreuses variantes possibles: consulter votre promoteur ou le président de jury en cas de doute sur l'opportunité de les utiliser!
\documentclass[11pt,a4paper,oneside]{report}
\usepackage[hmargin={1.25in,1.25in},vmargin={1.25in,1.25in}]{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%
\makeindex
\usepackage{textcomp}
\usepackage{fancyhdr}
\usepackage{makeidx}
\pagestyle{myheadings}
\fancyhf{}
\rhead[\leftmark]{thepage}
%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{natbib}

\usepackage[latin1]{inputenc}
\usepackage[francais]{babel}
\usepackage{url}
\usepackage{graphicx}
\usepackage{hyperref}

\begin{document}
%%%%%%%%%%%%%%%%
%\frontmatter
\begin{titlepage}


\begin{center}
\textbf{UNIVERSIT\'E LIBRE DE BRUXELLES}\\
\textbf{Faculté des Sciences}\\
\textbf{Département d'Informatique}
\vfill{}\vfill{}

%\begin{center}
{\Huge  Implementing a Dynamic and Global Scheduling Algorithm  \vspace*{.5cm}  \linebreak[4] in a Real-Time OS}
%\end{center}

{\Huge \par}
\begin{center}{\LARGE Arabella Brayer}\end{center}{\Huge \par}

\vfill{}

\begin{figure}[h]
	\begin{center}
	\includegraphics[width=3cm]{img/sceauquadri}
	\label{fig:sceauquadri}
	\end{center}
\end{figure}
\vfill{}



\begin{flushright}{\large \textbf{Promoteur : Joël Goossens}}\hfill{}{\large Travail préliminaire au mémoire}\\
{
%	 \large Prof. Prénom Nom
 }\hfill{}{\large Master 1}\\
\hfill{}{\large Science de l'informatique}\end{flushright}{\large\par}
\vfill{}\vfill{}\enlargethispage{3cm}
\textbf{Academic year 2016~-~2017}
\end{center}
\end{titlepage}
\newpage
\thispagestyle{empty} 
\null

\newenvironment{vcenterpage}
{\newpage\thispagestyle{empty} 
\vspace*{\fill}}
{\vspace*{\fill}\par\pagebreak}

\newpage
\thispagestyle{empty}
\vspace*{5cm}

\begin{quotation}
\noindent ``\emph{
	%TODO choose a quotation
	Vous pouvez aussi inclure une ou plusieurs citations générales en rapport avec votre sujet.
}''
\begin{flushright}\textbf{l'auteur (vrai ou supposé), date}\end{flushright}
\end{quotation}

\medskip

\begin{quotation}
\noindent ``\emph{Il existe des compilations de telles citations.}''
\begin{flushright}\textbf{autre auteur, date}\end{flushright}
\end{quotation}
%\chapter*{Remerciements}
%\thispagestyle{empty} 

%\noindent Je tiens à remercier ... 

%\medskip
%sans oublier les plus importants, exercice parfois délicat
\thispagestyle{empty} 
\setcounter{page}{0}
\tableofcontents
%\mainmatter 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRODUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% chapitre introduction

% TODO trouver meilleur nom qu'introduction, l'introduction est une partie de cette première partie.
\chapter{Introduction}
\setcounter{page}{1}
\begin{quotation}
	\noindent ``\emph{certains aiment insérer une ou des citations particulières, en rapport avec le chapitre.}''
	\begin{flushright}\textbf{auteur, date}\end{flushright}
\end{quotation}

\vspace*{0.5cm}

\section{Présentation générale du sujet}
%Blabla
%
%Pour une introduction rapide mais quand même bien détaillée de \LaTeX et \LaTeX2e, vous pouvez consulter, outre les bouquins classiques \cite{lamp,mittel}, le site \cite{oetik}.
%
%Vous aurez peut-être besoin d'utiliser d'autres packages que ceux mentionnés au début du fichier! Pour écrire des algorithmes, consultez par exemple le site \cite{fiorio}.

Depuis des décennies, le développement matériel et logiciel des équipements 
informatisés a bénéficié d'une croissance extrêmement importante, illustrée par 
la \href{http://ieeexplore.ieee.org/document/7878957/citations}{loi de Moore}.
En effet, durant les 40 dernières années, ce sont principalement les progrès
technologiques qui ont permis d'améliorer les vitesses d'exécution, 
grâce à la miniaturisation des composants, par exemple. 

Cela fait cependant plusieurs années que la croissance n'est plus 
simplement due à des améliorations physiques des composants en tant que tels. 
En effet, la multiplication des processeurs dans les ordinateurs a permis
de paralléliser et c'est ainsi que la quasi stagnation des 
technologies a pu être contournée pour continuer la progression.\\
% TODO add ref du cours de micro

Le monde des systèmes embarqués en temps réel n'a pourtant pas autant profité 
des mêmes avancées. 
Si la littérature autour des ordonnanceurs en temps réels illustre abondamment l'intérêt de l'intégration de cette parallélisation, 
les faits montrent plutôt que les industries continuent d'implémenter des solutions mono-processeur. 

Ceci peut s'expliquer en partie par le fait qu'il soit 
compliqué de gérer le partage des ressources, et que cette complexité 
n'apporte pas suffisamment d'avantages à l'heure qu'il est en terme de 
réduction de consommation énergétique ou en efficacité.\\

Il en résulte un décalage entre les connaissances théoriques et pratiques 
de ces ordonnanceurs. De ce point de vue, une implémentation sur un \textbf{RTOS}
tel qu'\textbf{HIPPEROS}\cite{HIPPEROS}
se rapprocherait d'un futur usage industriel et pourrait donc 
faire grandir la connaissance pratique. Cette implémentation 
pourrait amener plusieurs résultats intéressants : \\
\begin{itemize}
	\item Une comparaison entre des résultats théoriques et l'effet de leur mise 
	en \oe{}uvre
	\item L'origine de ces différences
	\item Vérifier les avantages, inconvénients ou obstacles à la 
	commercialisation de telles solutions.
\end{itemize}

\section{Contexte et objectifs}
\subsection{Ordonnanceurs globaux}
Depuis la preuve qu'aucun ordonnanceur global optimal n'existe pour toutes les classes 
de tâches,
[Hong and Leung \cite{hongandleung}, 1988] plusieurs candidats 
ordonnanceurs avec des propriétés différentes ont été proposés. 
Toutefois, ils sont encore assez peu utilisés actuellement dans l'industrie.\\

On peut cependant imaginer que la situation évolue dans les prochaines années. 
En effet, les systèmes embarqués vont également nécessiter de la puissance de calcul et
de l'efficacité. Les contraintes de partage de ressources se posent différemment 
dans le cas parallélisé, avec des contraintes d'accès à ces dernières, 
donc plus de complexité mais celle-ci pourrait en contrepartie apporter 
bien plus de performance.

%TODO pourquoi pas GPU ???

Le fait que l'industrie n'implémente pas à ce jour de solutions plus performantes 
pour les systèmes embarqués pose plusieurs problèmes :
\begin{enumerate}
	\item Le matériel n'est pas exploité de façon optimale.
	\item Par conséquent, on utilise bien plus d'énergie que nécessaire. 
	À l'heure actuelle, dans un monde où l'on cherche à consommer le moins possible, 
	cela pose question. Mais au delà, cela signifie également plus de maintenance 
	sur ces appareils parfois sans source de renouvellement d'énergie.
	\item Certains systèmes embarqués nécessitent une très basse consommation car 
	ils sont difficiles d'accès ou non faciles à recharger.
\end{enumerate}

Toutes ces raisons poussent à s'intéresser à une implémentation réelle et réaliste 
d'ordonnanceur connu dans la littérature, mais moins dans la réalité.

\subsection{HIPPEROS}
\textbf{HIPPEROS} (High Performance Parallel Embedded Real-time Operating Systems)
est un \textbf{RTOS} développé depuis plusieurs années par une spinoff de l'ULB.
Il bénéficie des connaissances apportées par le monde de la recherche dans 
le domaine des systèmes critiques avec multic\oe{}urs. Une de ses particularités 
est sa modularité, qui permet d'adapter ses possibilités en fonction du système 
lors de la compilation de l'OS, ainsi peut-on différencier deux installations 
en fonction des particularités.

\textbf{HIPPEROS} est un candidat idéal pour l'implémentation d'un ordonnanceur 
global, mais une partie du travail consistera à tirer parti de ses particularités. 
Par exemple, ce système d'exploitation gère les c\oe{}urs en leur attribuant des 
niveaux différents. L'un est considéré comme "maître" et les autres comme "esclaves". 
Ceci peut apporter un comportement particulier, ce auquel il convient d'apporter 
l'attention nécessaire. En résumé, une nouvelle implémentation sur un OS différent 
peut elle-aussi apporter à la connaissance générale des détails importants.


\section{Problématique}
L'ordonnanceur idéal, c'est à dire optimal pour toute classe de tâche n'existant pas, 
une partie du problème est donc de sélectionner l'un de ceux-ci parmi la liste 
d'ordonnanceurs connus (ne serait-ce que littérairement) afin que cela apporte 
à la connaissance générale, tant théorique que pratique.

Par ailleurs, pour certains des ordonnanceurs qui seront présentés dans l'état de l'art, 
certains ont déjà bénéficié d'une implémentation sur un \textbf{RTOS}. 
Il peut être également intéressant d'étudier la différence d'implémentation 
sur des OS différents, ainsi que les résultats obtenus. 
En effet, il est tout à fait possible que 


D'autre part, ils sont décrits dans la littérature de façon parfaitement théorique. Certains ont bénéficié d'une implémentation en \textbf{linux rt}. %TODO add ref
Mais alors, sur un autre ordonnanceur peut se poser le problème de la reproductibilité. 
Certains ordonnanceurs font des hypothèses fortes et le comportement réel pourrait 
être fort différent de celui décrit dans la littérature. 
Ces sujets seront évoqués dans l'état de l'art. %TODO verif que c'est fait

La question cruciale de cette première partie de travail 
consiste donc à faire un tour d'horizon de la littérature afin de pouvoir 
sélectionner un ordonnanceur pertinent à implémenter sur le \textbf{RTOS} \textbf{HIPPEROS}.

\section{Définitions et vocabulaire important}
\begin{itemize}
	\item\textbf{[RTOS}] : (Real Time Operating System) Système d'Exploitation Temps Réel.
	Un système d'exploitation Temps Réel est implémenté dans des systèmes à temps réel. 
	Il s'agit globalement de systèmes embarqués critiques, comme il en existe à ce jour 
	énormément (dans les avions, comme systèmes de contrôles, dans les voitures, etc.).
	Les contraintes ne sont pas les mêmes que dans un OS (\textbf{O}perating \textbf{S}ystem, Système d'Exploitation) classique, particulièrement pour
	l'ordonnanceur. 
	En effet, celui-ci doit gérer un ensemble de tâches qui doivent 
	(impérativement, ou pas) respecter des temps limites. 
	Attention cependant à ne pas confondre le besoin de synchronisation avec le besoin de rapidité : 
	tous les systèmes à temps réel n'ont pas forcément besoin de vitesse. 
	
	Il faut néanmoins s'assurer que tous les délais peuvent être respectés, et 
	c'est là une partie très importante du travail avant de mettre sur le 
	marché un système embarqué.\\
	%TODO https://fr.wikipedia.org/wiki/Syst%C3%A8me_d%27exploitation_temps_r%C3%A9el
	
	\item[\textbf{Contraintes strictes, contraintes relatives}] : Dans le cas strict, 
	le système doit impérativement respecter tous les temps limites. Aucun 
	dépassement n'est toléré. Dans le cas des contraintes relatives, ce respect 
	est moins impératif, et on pourra dépasser les délais occasionnellement. \\

	\item[Tâche] : 
	 
	\item[Temps d'exécution ] : Le temps d'exécution d'une tâche correspond au 
	temps requis afin d'exécuter entièrement une instance de cette tâche. 
	C'est le temps processeur requis. Ce temps est relatif à une tâche, 
	et pourrait varier pour diverses raisons. \\
	
	\item[Approche pire cas ] : Afin de faciliter les calculs et l'abstraction du 
	problème, l'on pose habituellement que le temps considéré d'exécution de 
	la tâche est le pire temps. Cela permet d'envisager le pire scénario, et ainsi 
	de s'assurer que si celui-ci est possible, alors dans de meilleures conditions, 
	la faisabilité est conservée. La notation utilisée dans le reste de ce document 
	est \textbf{WCET} : \textbf{W}orst \textbf{C}ase \textbf{E}xecution \textbf{T}ime
	
	
	\item[\textbf{Ordonnanceur}] : Un ordonnanceur (Scheduler) est la partie logicielle de 
	l'OS chargée d'orchestrer l'ordre d'exécution des tâches du système 
	selon des priorités fixées à l'avance ou en temps réel. 
	Dans un \textbf{RTOS}, ces priorités peuvent également être fixes ou dynamiques.\\
	
	\item[\textbf{préemption} ] : Un système est dit préemptif s'il a la capacité 
	de mettre l'exécution d'un job en pause et d'exécuter un autre à la place. 
	Une hypothèse pour simplifier la question théorique des ordonnanceur est 
	très souvent faite dans la littérature : on considère le temps de 
	préemption comme nul. Cette hypothèse est bien entendu fausse, et il faudra 
	en tenir compte, particulièrement dans ce travail où l'on tente de faire 
	le lien entre la théorie et la mise en pratique. 
	
\end{itemize}


etc. :

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%% ETAT DE L'ART %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%
%
%%%%%%%%%%%%%%%%%
%\part{Si du moins votre travail est divisé en parties}
%%%%%%%%%%%%%%%%%
\chapter{État de l'art}

La littérature sur le sujet des ordonnanceurs est assez vaste. 
Ceux-ci sont composés principalement de trois grandes familles :\\
\begin{itemize}
	\item Les mono-processeurs
	\item Les multi-processeurs partitionnés
	\item Les multiprocesseurs Globaux
\end{itemize}
Afin de respecter cette découpe assez naturelle, c'est de cette façon que nous 
avons organisé la présentation de l'état de l'art, bien que 
d'autres découpes auraient été possibles.

\section{Ordonnanceurs mono processeur}
\subsection{Une famille plus "facile" à ordonnancer}

\subsection{Rate Monotonic}

\subsection{Earliest Deadline First}


\section{Famille des multi-processeurs partitionnés}
\subsection{EDF}
%TODO revoir cours de goossens

\section{Famille des multi-processeurs globaux}
\subsection{EDF-k}

\section{Conclusion}
% tableau ? Support pour développer argumentation ?

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}


