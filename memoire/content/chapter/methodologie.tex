
% pour répondre à la question, il faut :

\section{Choix de l'ordonnanceur à implémenter}

	\subsection{Présentation UEDF}
	
	Nous avons déjà présenté précédemment \textbf{UEDF}, de façon globale et succincte. 
	Dans cette partie, nous allons un peu plus en profondeur 
	
	\textbf{UEDF} est un ordonnanceur qui comporte plusieurs intérêts pour une implémentation.
	Tout d'abord, il est principalement \textit{en ligne}\todo{verif glossaire}, ce qui n'est pas le cas de 
	la plupart des ordonnanceurs utilisés dans l'industrie.
	Ensuite, il est global.\todo{include lien vers glossaire} Or, la plupart des ordonnanceurs 
	globaux connus et implémentés ne sont pas optimaux (pour la classe périodique), pour la
	raison exposée au préalable dans ce travail : il est nécessaire d'avoir de la clairvoyance, 
	c'est à dire une connaissance relative du futur.
	
	\textbf{UEDF} fait face à ce problème en ayant une vision non pas verticale, mais horizontale 
	de l'ordonnancement des tâches. 

		\subsubsection{Global EDF}
		Afin de montrer la particularité d'\textbf{UEDF}, nous commençons par rappeler le fonctionnement 
		d'un ordonnanceur bien connu et que l'on peut considérer comme "vertical" : \textbf{Global EDF}. \todo{link état de l'art}
		
		L'algorithme est extrêmement simple. On conserve une structure de données 
		ordonnée, comme un \textbf{Heap} \todo{glossaire} qui contient tous les jobs 
		devant être exécutés. À chaque fois que l'ordonnanceur doit prendre 
		une décision, il lui suffit de prendre le job de priorité supérieure et 
		de l'exécuter sur le processeur libre.
		
		L'algorithme ne calcule rien à propos de l'avenir, sa décision au moment t
		n'est prise qu'en considérant les jobs à exécuter et la liberté d'un 
		processeur. Il se peut qu'un autre ordonnancement plus efficace 
		réussisse à ordonnancer un système que Global EDF ne puisse pas résoudre...
		Cela rend tout de même l'ordonnanceur "efficace" en terme de calculs, 
		puisqu'il comporte un Heap (nlogn) persistant, qui sera mis à jour 
		à chaque changement d'état du job (relâché -> inséré, 
		exécuté -> retiré du heap).
		
		En revanche, ce fonctionnement ne permet pas à cet ordonnanceur d'atteindre 
		l'optimalité pour la classe de systèmes périodiques, comme on peut le voir 
		avec cet exemple :
		\todo{montrer un exemple qui rende Global EDF non efficace pour un job}

		\subsubsection{UEDF}
		UEDF -- quant à lui -- résout ce problème en effectuant un pré-calcul 
		que l'on pourrait comparer à un partitionnement, mais en ligne.
		En résumé, à chaque fois qu'un job est activé, un calcul va permettre 
		de réserver des portions de temps pour toutes les tâches actives 
		actuellement dans le système. Au lieu de ne prendre en considération que 
		les priorités et les processeurs libres, UEDF vérifie donc à 
		chaque nouvelle libération de tâche que l'ordonnancement peut se faire. 
		En théorie, on devrait donc savoir immédiatement si un système est ordonnançable, avant même de croiser un dépassement d'échéance. 
		
		
		Ainsi, la décision n'est pas réellement prise à ce moment, 
		mais on sait déjà qu'un job peut-être effectué sur un 
		processeur, en garantissant le respect de l'échéance.
		
		La décision est ensuite prise à chaque événement de ce type :
		\begin{enumerate}
			\item Relâchement de tâche
			\item Job terminé
		\end{enumerate}

		En l'occurrence, à ce moment, il suffit de procéder comme pour \textbf{GlobalEDF} et de sélectionner le job le plus prioritaire, en respectant 
		une règle simple : effectuer le job de priorité supérieure, sauf s'il 
		est déjà en train d'être exécuté sur un autre processeur. Auquel cas, on ne 
		fait pas de migration, on prend simplement le job suivant sur la liste.
		
		\todo{cette explication serait même incompréhensible pour quelqu'un connaissant bien UEDF... REFORMULER !! }
		\todo{illustration simple avec dessin}
		
		Nous appelons ce fonctionnement "horizontal" car au lieu de remplir 
		en priorité les processeurs "libres", UEDF va remplir les 
		processeurs par ordre. Ainsi, pour une utilisation inférieure à 100\%, 
		on n'aura besoin que d'un seul processeur. Pour 200, 2 processeurs, bref, 
		pour une utilisation de m * 100 \%, on utilisera m processeurs.
		
		
		

\subsection{Difficultés liées à l'implémentation}
	\subsubsection{datastructure}
	\subsubsection{Complexité/persistance}
	\subsubsection{WCET}
	\subsubsection{S'arrête à chaque event}
	\subsubsection{Utilisation de 100\%, mais et les interruptions alors ?}

\section{La vérification de l'implémentation : tests unitaires simulés avec des sets créés}

\section{Tests globaux}

\section{Comparaison avec G-EDF}
