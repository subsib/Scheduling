\section{Choix de l'ordonnanceur}

	\subsection{Enjeux du choix de l'ordonnanceur}

	L'état de l'art nous a montré un vaste choix d'algorithmes qui présentent 
	des intérêts différents, et pour un certain nombre, 
	n'ayant pas pas encore été implémentés. \newline
	
	La première étape du travail consiste donc à départager ces algorithmes pour arrêter notre choix sur l'un d'entre eux. Ceci nécessite de clarifier nos attentes concernant le choix de l'ordonnanceur.\newline
	
	Pour rappel, les objectifs de ce travail sont de procéder à une implémentation dans 
	un \textbf{RTOS} dans plusieurs buts. 
	D'abord, en implémentant un algorithme qui n'a pas d'implémentation connue, nous 
	pouvons vérifier que ce passage de la théorie à la pratique est possible (car cela n'est pas 
	toujours évident), nous pouvons également mesurer ses performances. 
	Plus largement, nous pouvons émettre des propositions à l'attention de chercheurs 
	afin qu'ils puissent envisager de développer certains points lorsqu'ils proposent de nouveaux algorithmes. \newline
	
	Il est donc primordial de se tourner vers un algorithme qui pourra apporter sur le plan de 
	l'expérience des analyses intéressantes, c'est à dire exploitables pour la communauté. 
	Insistons peut-être sur le fait que des résultats ne sont pas nécessairement chiffrés mais 
	peuvent être des constats qualitatifs quant à la mise en œuvre elle-même.\newline
	
	\subsection{Pourquoi UEDF}
	
	Le choix le plus rationnel vis à vis des objectifs devrait se faire en fonction des 
	promesses théoriques de performance et de stabilité. 
	En effet, pour faire avancer la connaissance et permettre d'augmenter la confiance des utilisateurs 
	potentiels, il est judicieux de choisir un algorithme dont on attend au moins ceci :
	\begin{itemize}
		\item Un algorithme global
		\item Qui minimise le nombre de migrations
		\item L'ordonnanceur est en ligne, optimal pour la classe périodique
		\item Il n'a pas bénéficié d'une implémentation sur un \textbf{RTOS}
		\item Il promet des performances intéressantes
	\end{itemize}
	
	Le premier choix a été \hyperref[RUN]{RUN}[\ref*{RUN}], puis finalement, son descendant, \hyperref[QPS]{QPS}[\ref*{QPS}]. Ces choix étant guidés 
	sur leur intérêt d'ordonnanceurs en tant que tels.
	Toutefois, l'aspect très théorique des papiers les présentant a rendu la première phase de travail difficile. 
	En outre, nous n'avons pas trouvé d'implémentation ou de simulation malgré nos recherches.
	Finalement, nous n'avons pas réussi à entrer en contact avec les créateurs de ces algorithmes. \newline
	
	En effet, la possibilité de contacter les créateurs d'un algorithme peut singulièrement améliorer le 
	travail. Cela étant, cette nécessité découle du caractère très théorique de la littérature disponible
	et du manque fréquent de prise en considération des contraintes pratiques d'implémentation. 
	Pour illustrer cette remarque, un exemple assez commun est la non prise en considération 
	du fait que le fonctionnement des ordinateurs est évidemment discret, là où les 
	calculs présentés se basent sur un fonctionnement continu.
	Toute mise en pratique nécessite de faire des arrondis, ceux-ci doivent être cohérents.\newline

\todo{ajouter surcout dans le glossaire}
	Nous pouvons aussi évoquer les moments où l'algorithme doit faire des calculs. 
	Dans un simulateur, ou dans une vision idéalisée de l'ordonnanceur, l'on peut arrêter l'exécution 
	quand on le veut, avec des temps de surcoût [\ref*{surcout}]négligeables. Dans la réalité, comme on le verra, cela 
	n'est pas le cas. 
	Les auteurs qui connaissent bien ce fonctionnement auront la possibilité de devancer certaines questions.
	Néanmoins, dans le cas d'un papier très théorique qui s'emploie à faire des démonstrations mathématiques, 
	cela n'apparaîtra pas forcément.\newline
	
	\textbf{UEDF} bénéficie quant à lui d'une littérature qui développe mieux l'aspect pratique, et cela a orienté notre choix.\newline
	
	\todo{déplacer ça ailleurs}
	De plus, il y a des difficultés particulières liées au fait qu'un ordonnanceur ne soit qu'une partie d'un ensemble : 
	un \textbf{RTOS}. En effet, l'ordonnanceur n'est qu'une partie du kernel, et dépend de l'implémentation 
	d'autres parties du kernel, comme du dispatcher. Le travail d'implémentation d'un ordonnanceur ne consiste 
	pas à modifier tout le RTOS, mais à ajouter une partie du kernel. On ne peut 
	pas considérer l'ordonnanceur comme une tâche indépendante du reste du kernel, cela 
	implique un certain nombre de contraintes et de difficultés.\newline
	
	En d'autres termes, l'implémentation d'un ordonnanceur peut s'avérer une tâche bien compliquée selon que l'auteur du papier décrivant l'algorithme 
	ait une bonne connaissance des \textbf{RTOS} ou pas. 
	\newline

	
	Finalement, c'est un argument quant à la communication (clarté, possibilité de poser des questions) 
	qui a fixé le choix. Par conséquent, c'est \textbf{UEDF} qui a été sélectionné, car 
	non seulement il respectait 
	les promesses énoncées auparavant, mais aussi, en plus d'être très bien documenté, 
	nous pouvions poser nos questions directement à l'un de ses créateurs. Néanmoins, ses paramètres sont moins idéaux, 
	et nous avons revu nos attentes quant à l'efficacité à la baisse. Cela n'a en rien 
	modifié l'objet scientifique, à savoir le regard critique et la proposition d'améliorations 
	afin de stimuler et faciliter des implémentations futures, mais cela a sans doute 
	diminué les performances finales obtenues, tel que nous le verrons dans la partie Résultats.\newline
	

\section{La vérification de l'implémentation : tests unitaires simulés avec des sets créés}

	Une des difficultés rencontrée lors de l'implémentation d'\textbf{UEDF} a été de s'assurer de la correction de l'algorithme. 
	Aucune autre implémentation n'était accessible sur un autre \textbf{RTOS}, de fait, et donc il n'y avait pas de 
	comparaison possible. En outre, nous trouvons bien un invariant dans la thèse de G. Nelissen, ce qui assure 
	que l'algorithme a bien réservé du temps pour toutes les tâches présentes dans l'ensemble 
	(ce qui doit être vrai pour tout système où $instant\_utilisation <= m$), mais ne garantit pas 
	qu'il n'y a pas d'erreurs ensuite dans la répartition des sous-systèmes, etc. Pour cela, il faut encadrer 
	l'exécution d'autres tests. \newline

	Avant de nous lancer dans l'exécution réelle de l'algorithme, une grande partie du travail a consisté 
	à simuler l'exécution du programme à l'aide de tests unitaires. Ceux-ci ont été pensés de sorte à avoir 
	une couverture relativement élevée du code (50 \% environ) afin d'éviter les surprises lors du passage 
	

\section{Tests globaux}

\subsection{Génération de tâches}

\subsection{Surcoûts}

\section{Comparaison avec G-EDF}
